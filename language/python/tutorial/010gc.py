'''
python垃圾回收
1、概述：
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用
计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的
问题。在“标记-清除”基础上，通过“分代回收”（generation collection）以空间换取时间来进
一步提高垃圾回收的效率。

2、引用计数：
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	在Python中，大多数对象的生命周期都是通过对象的引用计数来管理的。从广义上来讲，引用
计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。

	原理：当一个对象的引用被创建或者引用赋值时，对象的引用计数加1；当一个对象的引用被销
毁时，对象的引用计数减1；当对象的引用计数减少为0时，就意味着对象已经没有被任何人使用了，
可以将其所占用的内存释放了。

	虽然引用计数必须在每次分配和释放内存的时候加入管理引用计数的动作，然而与其他主流的
垃圾收集技术相比，引用计数有一个最大的有点，即“实时性”，任何内存，一旦没有指向它的引用，
就会立即被回收。而其他的垃圾收集计数必须在某种特殊条件下（比如内存分配失败）才能进行无效
内存的回收。

	引用计数机制执行效率问题：引用计数机制所带来的维护引用计数的额外操作与Python运行中
所进行的内存分配和释放，引用赋值的次数是成正比的。而这点相比其他主流的垃圾回收机制，
比如“标记-清除”，“停止-复制”，是一个弱点，因为这些技术所带来的额外操作基本上只是与待回
收的内存数量有关。

	如果说执行效率还仅仅是引用计数机制的一个软肋的话，那么很不幸，引用计数机制还存在着
一个致命的弱点，正是由于这个弱点，使得狭义的垃圾收集从来没有将引用计数包含在内，能引发
这个致命的弱点就是循环引用（也称交叉引用）。

	问题说明：如果两个对象循环引用，彼此指向对方，那即使没有其它名字引用它们，它俩的引
用计数也为1，但实际上它们已经不可达，属于应被回收的对象。这一点是致命的，这与手动进行内
存管理所产生的内存泄露毫无区别。

	要解决这个问题，Python引入了其他的垃圾收集机制来弥补引用计数的缺陷：“标记-清除”，
“分代回收”两种收集技术。

3、标记-清除
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	“标记-清除”是为了解决循环引用的问题。可以包含其他对象引用的容器对象（比如：list，
set，dict，class，instance）都可能产生循环引用。

	我们必须承认一个事实，如果两个对象的引用计数都为1，但是仅仅存在他们之间的循环引用，
那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非0，但实际上有效的引
用计数为0。我们必须先将循环引用摘掉，那么这两个对象的有效计数就现身了。假设两个对象为A、B，
我们从A出发，因为它有一个对B的引用，则将B的引用计数减1；然后顺着引用达到B，因为B有一个
对A的引用，同样将A的引用减1，这样，就完成了循环引用摘除。

	高效算法：基于这个一个认识，那就是：不能回收的对象所指向的对象也都是不能回收的对象。
设计两个集合，一个放置需回收的对象，一个放置不能回收的对象。初始状态下，所有对象都在需回
收的集合中，(1)从中找出一个不可回收对象放置到不可回收集合中，(2)然后这个对象所指向的所有
对象都放置到不可回收集合中，把这些对象都放到不可回收集合中，(2)递归，回(1)循环。现在，在
需回收集合中的所有对象就是真实的需回收的对象。

	"标记-清除"逻辑是定时操作的，所以循环引用回收是有延迟的。

4、分代回收
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	背景：分代的垃圾收集技术是在上个世纪80年代初发展起来的一种垃圾收集机制，一系列的研
究表明：无论使用何种语言开发，无论开发的是何种类型，何种规模的程序，都存在这样一点相同
之处。即：一定比例的内存块的生存周期都比较短，通常是几百万条机器指令的时间，而剩下的内存
块，起生存周期比较长，甚至会从程序开始一直持续到程序结束。

	从前面“标记-清除”这样的垃圾收集机制来看，这种垃圾收集机制所带来的额外操作实际上与程
序中总的内存块的数量是相关的，当需要回收的内存块越多时，垃圾检测带来的额外操作就越多；反
之，当需回收的内存块越少时，垃圾检测带来的额外操作就越少。为了提高垃圾收集的效率，采用“
空间换时间的策略”。

	原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，
垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，
就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡
量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。

举例说明：
	当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，
而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，
而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，
效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，
当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。

	在Python中，总共有3“代”，也就是Python实际上维护了3条链表。具体可以查看Python源码
详细了解。
'''