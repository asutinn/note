1、介绍
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
http://www.cs.fsu.edu/~engelen/soap.html

英文说明
Customizing XML data bindings with the typemap.dat file

	The typemap.dat file for the wsdl2h tool can be used to customize or 
optimize the type bindings by mapping schema types to C/C++ types. This file 
contains custom XML schema to C/C++ type bindings and XML namespace bindings for 
namespace prefixes to be generated by the wsdl2h tool. You can edit this file to 
enable features such as custom serializers for schema types, C++11 smart pointers 
to replace regular pointers, bind XML namespace prefixes to XML namespace URIs, 
and specify bindings for schema types.

gsoap的wsdl2h工具可以使用typemap.dat文件定制XML数据的绑定
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	wsdl2h工具使用typemap.dat文件定制和优化类型绑定（xml schema types -> C/C++
类型）。除了类型绑定，typemap.dat还提供命名空间绑定。常见的功能如下：
	定制schema类型的通用序列化
	用c++11智能指针代替普通指针
	绑定XML命名空间前缀到XML命名空间URIS
	指定schema类型的绑定

2、类型绑定的语法
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Type bindings语句用于控制XML schema types向C/C++类型的转换，语句有4个部分：
prefix__type = declaration | use | ptr-use

四个部分的含义：
	prefix__type：这是schema type的C/C++类型名（使用 gSOAP的类型命名规则）
	declaration:  类型在wsdl2h生成的头文件中定义，可以为空
	use:          但此类型用作其它类型的成员或函数参数时，在wsdl2h生成的头文件中怎么替换
	ptr-use:      以指针方式做其它类型的成员或函数参数时如何替换（譬如wsdl2h翻译
minOccurs、maxOccurs属性的变量时可能会使用指针，此时如果有此变量的指针替换语法，则会
拿它代替）

一个例子：
<xs:complexType name="ActionEngineEventPayload">
	<xs:sequence>
		<xs:element name="RequestInfo" type="soapenv:Envelope" minOccurs="0" maxOccurs="1">
			<xs:annotation>
				<xs:documentation>Request Message</xs:documentation>
			</xs:annotation>
		</xs:element>
	</xs:sequence>
</xs:complexType>
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	ActionEngineEventPayload是复杂类型，它有一个成员叫RequestInfo。RequestInfo的
类型是soapenv:Envelope。

	soapenv:Envelope引用http://www.w3.org/2003/05/soap-envelope中的Envelope类型，
根据gSOAP的类型命名规则（不了解这个规则），它的C/C++名字叫SOAP_ENV__Header(即prefix__type)

	情况1：我们把RequestInfo的minOccurs设置为1，maxOccurs也设置为1，
typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    struct SOAP_ENV__Envelope            RequestInfo                    1;	///< Required element.
};

typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope* | int
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    struct SOAP_ENV__Envelope*           RequestInfo                    1;	///< Required element.
};

这种情况下不会使用Type bindings语法的第四部分

	情况2：我们把RequestInfo的minOccurs设置为0，maxOccurs也设置为1
typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    struct SOAP_ENV__Envelope*           RequestInfo                    0;	///< Optional element.
};

typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | | int
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    int                                  RequestInfo                    0;	///< Optional element.
};
