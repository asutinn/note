	PAYLOAD_TYPE_E enPayLoad= PT_H264;
	PIC_SIZE_E enSize;
	HI_U32 u32Profile = 0;

	/*
	 * @VB_CONF_S是视频缓存池属性结构体
	 *
	 *	一组大小相同、物理地址连续的缓存块组成一个视频缓存池。缓存池的数目
	 *每个缓存池块的大小和块的数目都是可以配置的。
	 *
	 *	VI模块从视频缓存池获取一个缓存块，存入从sensor获取到的图像，经VPSS、VENC
	 *模块后把块还给缓存池。
	 *
	 */
	VB_CONF_S stVbConf;

	SAMPLE_RC_E enRcMode= SAMPLE_RC_CBR;

	HI_S32 s32Ret = HI_SUCCESS;
	HI_U32 u32BlkSize;
	SIZE_S stSize;

	/*
	 * @step1: init sys variable
	 */
	memset(&stVbConf,0,sizeof(VB_CONF_S));
	SAMPLE_COMM_VI_GetSizeBySensor(&enSize);

	/*
	 * @缓存池有VB_MAX_POOLS即256个，每个池有两个块，每个块的大小为
	 *一幅原始图像大小。
	 */
	stVbConf.u32MaxPoolCnt = VB_MAX_POOLS;
	u32BlkSize = SAMPLE_COMM_SYS_CalcPicVbBlkSize(gs_enNorm,\
			enSize, SAMPLE_PIXEL_FORMAT, SAMPLE_SYS_ALIGN_WIDTH);
	stVbConf.astCommPool[0].u32BlkSize = u32BlkSize;
	/*
	 * @这里设置得小，譬如2会导致MPP不工作，也不返回错误，这个
	 *bug还不太好发现。
	 */
	stVbConf.astCommPool[0].u32BlkCnt = 20;

	/*
	 * @step2: mpp system init. 
	 */
	s32Ret = SAMPLE_COMM_SYS_Init(&stVbConf);
	if(HI_SUCCESS != s32Ret)
	{
		printf("system init failed with %d!\n", s32Ret);
		SAMPLE_COMM_SYS_Exit();
		return;
	}


	//dfs_mpp_overlay_add();


	/*
	 * @step3: start vi dev & chn to capture
	 *SENSOR_TYPE定义在hi_common.h中
	 */
	s32Ret = SAMPLE_COMM_VI_StartVi(&g_sViConfig);
	if(HI_SUCCESS != s32Ret)
	{
		printf("start vi failed!\n");
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	/*
	 * @step4: start vpss and vi bind vpss
	 */
	s32Ret = SAMPLE_COMM_SYS_GetPicSize(gs_enNorm, enSize, &stSize);
	if(HI_SUCCESS != s32Ret)
	{
		printf("SAMPLE_COMM_SYS_GetPicSize failed!\n");
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	/*
	 * @VPSS有group的概念，VI和VENC没有
	 */
	VPSS_GRP_ATTR_S stVpssGrpAttrT;
	stVpssGrpAttrT.u32MaxW = stSize.u32Width;
	stVpssGrpAttrT.u32MaxH = stSize.u32Height;
	stVpssGrpAttrT.bIeEn = HI_FALSE;
	stVpssGrpAttrT.bNrEn = HI_TRUE;
	stVpssGrpAttrT.bHistEn = HI_FALSE;
	stVpssGrpAttrT.bDciEn = HI_FALSE;
	stVpssGrpAttrT.enDieMode = VPSS_DIE_MODE_NODIE;
	stVpssGrpAttrT.enPixFmt = SAMPLE_PIXEL_FORMAT;
	s32Ret = SAMPLE_COMM_VPSS_StartGroup(g_iVpssGrp, &stVpssGrpAttrT);
	if(HI_SUCCESS != s32Ret)
	{
		printf("Start Vpss failed!\n");
		SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	/*
	 * @这个函数只能绑定0号group，如使用其它group，需修改。
	 */
	s32Ret = SAMPLE_COMM_VI_BindVpss(g_sViConfig.enViMode);
	if(HI_SUCCESS != s32Ret)
	{
		printf("Vi bind Vpss failed!\n");
		SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
		SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	/*
	 * @对group做帧率控制
	 */
	VPSS_FRAME_RATE_S sVpssFrameRateT;
	sVpssFrameRateT.s32SrcFrmRate = 60;        /* Input frame rate of a  group*/
	sVpssFrameRateT.s32DstFrmRate = 25;        /* Output frame rate of a channel group */
	s32Ret = HI_MPI_VPSS_SetGrpFrameRate(g_iVpssGrp, &sVpssFrameRateT);
	if(HI_SUCCESS != s32Ret)
	{
		printf("HI_MPI_VPSS_SetGrpFrameRate failed!\n");
		SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
		SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	/*
	 * @物理通道1：user模式、YUVSP420输出、无压缩输出、不裁剪
	 */
	VPSS_CHN_ATTR_S stVpssChn1AttrT;
	VPSS_CHN_MODE_S stVpssChn1ModeT;
	stVpssChn1ModeT.enChnMode      = VPSS_CHN_MODE_USER;
	stVpssChn1ModeT.bDouble        = HI_FALSE;
	stVpssChn1ModeT.enPixelFormat  = PIXEL_FORMAT_YUV_SEMIPLANAR_420;//SAMPLE_PIXEL_FORMAT;  PIXEL_FORMAT_YUV_SEMIPLANAR_420
	stVpssChn1ModeT.u32Width       = stSize.u32Width;
	stVpssChn1ModeT.u32Height      = stSize.u32Height;
	stVpssChn1ModeT.enCompressMode = COMPRESS_MODE_NONE;  //COMPRESS_MODE_SEG; 这里不能选压缩算法，不然HI_MPP_VPSS_GetChaFrame的结果麻烦
	memset(&stVpssChn1AttrT, 0, sizeof(stVpssChn1AttrT));
	stVpssChn1AttrT.s32SrcFrameRate = -1;
	stVpssChn1AttrT.s32DstFrameRate = -1;
	s32Ret = SAMPLE_COMM_VPSS_EnableChn(g_iVpssGrp, g_iVpssChn1, &stVpssChn1AttrT, &stVpssChn1ModeT, HI_NULL);
	if(HI_SUCCESS != s32Ret)
	{
		printf("Enable vpss chn failed!\n");
		SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn1);
		SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
		SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	/*
	 * @物理通道2：user模式、YUVSP420输出、无压缩输出
	 */
	// VPSS_CHN_ATTR_S stVpssChn2AttrT;
	// VPSS_CHN_MODE_S stVpssChn2ModeT;
	// stVpssChn2ModeT.enChnMode      = VPSS_CHN_MODE_USER;
	// stVpssChn2ModeT.bDouble        = HI_FALSE;
	// stVpssChn2ModeT.enPixelFormat  = PIXEL_FORMAT_YUV_SEMIPLANAR_420;//SAMPLE_PIXEL_FORMAT;  PIXEL_FORMAT_YUV_SEMIPLANAR_420
	// stVpssChn2ModeT.u32Width       = stSize.u32Width;  //控制缩放，缩放在裁剪之前，这里我们不缩放
	// stVpssChn2ModeT.u32Height      = stSize.u32Height;
	// stVpssChn2ModeT.enCompressMode = COMPRESS_MODE_NONE;  //COMPRESS_MODE_SEG; 这里不能选压缩算法，不然HI_MPP_VPSS_GetChaFrame的结果麻烦
	// memset(&stVpssChn2AttrT, 0, sizeof(stVpssChn2AttrT));
	// stVpssChn2AttrT.s32SrcFrameRate = 60;
	// stVpssChn2AttrT.s32DstFrameRate = 25;
	// s32Ret = SAMPLE_COMM_VPSS_EnableChn(g_iVpssGrp, g_iVpssChn2, &stVpssChn2AttrT, &stVpssChn2ModeT, HI_NULL);
	// if(HI_SUCCESS != s32Ret)
	// {
	// 	printf("Enable vpss chn failed!\n");
	// 	SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2);
	// 	SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn1);
	// 	SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
	// 	SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
	// 	SAMPLE_COMM_VI_StopVi(&g_sViConfig);
	// 	SAMPLE_COMM_SYS_Exit();
	// 	return;
	// }

	/*
	 * @物理通道2：裁剪
	 */
	// VPSS_CROP_INFO_S sVpssCropInfo2T;
	// sVpssCropInfo2T.bEnable              = HI_TRUE;
	// sVpssCropInfo2T.enCropCoordinate     = VPSS_CROP_ABS_COOR;
	// sVpssCropInfo2T.stCropRect.s32X      = 0;
	// sVpssCropInfo2T.stCropRect.s32Y      = 0;
	// sVpssCropInfo2T.stCropRect.u32Width  = stSize.u32Width;
	// sVpssCropInfo2T.stCropRect.u32Height = stSize.u32Height;
	// s32Ret = HI_MPI_VPSS_SetChnCrop(g_iVpssGrp, g_iVpssChn2, &sVpssCropInfo2T);
	// if(HI_SUCCESS != s32Ret)
	// {
	// 	printf("Enable vpss chn failed!\n");
	// 	SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2);
	// 	SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn1);
	// 	SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
	// 	SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
	// 	SAMPLE_COMM_VI_StopVi(&g_sViConfig);
	// 	SAMPLE_COMM_SYS_Exit();
	// 	return;
	// }

	/*
	 * @物理通道2挂载扩展通道1
	 */
	// VPSS_EXT_CHN_ATTR_S sVpssChn2ExtChn1AttrT;
	// sVpssChn2ExtChn1AttrT.s32BindChn      = g_iVpssChn2;
	// sVpssChn2ExtChn1AttrT.u32Width        = stSize.u32Width; 
	// sVpssChn2ExtChn1AttrT.u32Height       = stSize.u32Height; 
	// sVpssChn2ExtChn1AttrT.s32SrcFrameRate = 25; 
	// sVpssChn2ExtChn1AttrT.s32DstFrameRate = 10; 
	// sVpssChn2ExtChn1AttrT.enPixelFormat   = PIXEL_FORMAT_YUV_SEMIPLANAR_420; 
	// sVpssChn2ExtChn1AttrT.enCompressMode  = COMPRESS_MODE_NONE;
	// s32Ret = SAMPLE_COMM_VPSS_EnableChn(g_iVpssGrp, g_iVpssChn2ExtChn1, HI_NULL, HI_NULL, &sVpssChn2ExtChn1AttrT);
	// if(HI_SUCCESS != s32Ret)
	// {
	// 	printf("SAMPLE_COMM_VPSS_EnableChn21 failed!\n");
	// 	SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2ExtChn1);
	// 	SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2);
	// 	SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn1);
	// 	SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
	// 	SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
	// 	SAMPLE_COMM_VI_StopVi(&g_sViConfig);
	// 	SAMPLE_COMM_SYS_Exit();
	// 	return;
	// }

	/*
	 * @物理通道2挂载扩展通道2
	 */




	/*
	 @step5: start stream venc
	 */
	enRcMode = SAMPLE_RC_CBR;//码率控制器
	s32Ret = SAMPLE_COMM_VENC_Start(g_iVencChn, enPayLoad,\
				gs_enNorm, enSize, enRcMode, u32Profile);
	if(HI_SUCCESS != s32Ret)
	{
		printf("Start Venc failed!\n");
		SAMPLE_COMM_VENC_Stop(g_iVencChn);
		//SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2ExtChn1);
		//SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2);
		SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn1);
		SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
		SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	s32Ret = SAMPLE_COMM_VENC_BindVpss(g_iVencChn, g_iVpssGrp, g_iVpssChn1);
	if(HI_SUCCESS != s32Ret)
	{
		printf("Start Venc failed!\n");
		SAMPLE_COMM_VENC_UnBindVpss(g_iVencChn, g_iVpssGrp, g_iVpssChn1);
		SAMPLE_COMM_VENC_Stop(g_iVencChn);
		//SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2ExtChn1);
		//SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn2);
		SAMPLE_COMM_VPSS_DisableChn(g_iVpssGrp, g_iVpssChn1);
		SAMPLE_COMM_VI_UnBindVpss(g_sViConfig.enViMode);
		SAMPLE_COMM_VPSS_StopGroup(g_iVpssGrp);
		SAMPLE_COMM_VI_StopVi(&g_sViConfig);
		SAMPLE_COMM_SYS_Exit();
		return;
	}

	/*
	 * @创建读视频编码线程
	 */
	bReadVideoKeepalive = true;
	//pthread_create(&g_ReadVideoThreadId, 0, read_video_thread_fun, NULL/*(HI_VOID*)&gs_stPara*/);
	pthread_create(&g_ReadVideoThreadId, 0, SAMPLE_COMM_VENC_GetVencStreamProcsent, NULL/*(HI_VOID*)&gs_stPara*/);