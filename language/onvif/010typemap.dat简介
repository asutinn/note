1、介绍
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
http://www.cs.fsu.edu/~engelen/soap.html

英文说明
Customizing XML data bindings with the typemap.dat file

	The typemap.dat file for the wsdl2h tool can be used to customize or 
optimize the type bindings by mapping schema types to C/C++ types. This file 
contains custom XML schema to C/C++ type bindings and XML namespace bindings for 
namespace prefixes to be generated by the wsdl2h tool. You can edit this file to 
enable features such as custom serializers for schema types, C++11 smart pointers 
to replace regular pointers, bind XML namespace prefixes to XML namespace URIs, 
and specify bindings for schema types.

gsoap的wsdl2h工具可以使用typemap.dat文件定制XML数据的绑定
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	wsdl2h工具使用typemap.dat文件定制和优化类型绑定（xml schema types -> C/C++
类型）。除了类型绑定，typemap.dat还提供命名空间绑定。常见的功能如下：
	定制schema类型的通用序列化
	用c++11智能指针代替普通指针
	绑定XML命名空间前缀到XML命名空间URIS
	指定schema类型的绑定

2、类型绑定的语法
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Type bindings语句用于控制XML schema types向C/C++类型的转换，语句有4个部分：
prefix__type = declaration | use | ptr-use

四个部分的含义：
	prefix__type：这是schema type的C/C++变量名（使用gSOAP的类型命名规则，譬如xml
中xsd:string对应的C/C++变量名就是xsd__string；soapenv:Envelope对应SOAP_ENV__Envelope，
注意xml前缀与名称之间的:被替换为两个小横线）
	declaration:  类型在wsdl2h生成的头文件中定义，可以为空
	use:          但此类型用作其它类型的成员或函数参数时，在wsdl2h生成的头文件中怎么替换
	ptr-use:      以指针方式做其它类型的成员或函数参数时如何替换（譬如wsdl2h翻译
minOccurs、maxOccurs属性的变量时可能会使用指针，此时如果有此变量的指针替换语法，则会
拿它代替）

一个例子：
<xs:complexType name="ActionEngineEventPayload">
	<xs:sequence>
		<xs:element name="RequestInfo" type="soapenv:Envelope" minOccurs="0" maxOccurs="1">
			<xs:annotation>
				<xs:documentation>Request Message</xs:documentation>
			</xs:annotation>
		</xs:element>
	</xs:sequence>
</xs:complexType>
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	ActionEngineEventPayload是复杂类型，它有一个成员叫RequestInfo。RequestInfo的
类型是soapenv:Envelope。

	soapenv:Envelope引用http://www.w3.org/2003/05/soap-envelope中的Envelope类型，
根据gSOAP的类型命名规则（不了解这个规则），它的C/C++名字叫SOAP_ENV__Envelope(即prefix__type)

【注】
	minOccurs、maxOccurs取值会影响xml->c/c++时是使用对象还是指针。

	情况1：我们把RequestInfo的minOccurs设置为1，maxOccurs也设置为1，
typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    struct SOAP_ENV__Envelope            RequestInfo                    1;	///< Required element.
};

typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope* | int
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    struct SOAP_ENV__Envelope*           RequestInfo                    1;	///< Required element.
};

这种情况下不会使用Type bindings语法的第四部分

	情况2：我们把RequestInfo的minOccurs设置为0，maxOccurs也设置为1
typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | struct SOAP_ENV__Envelope
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    struct SOAP_ENV__Envelope*           RequestInfo                    0;	///< Optional element.
};

typemap.dat中这样定义：
SOAP_ENV__Envelope      = struct SOAP_ENV__Envelope {struct SOAP_ENV__Header *SOAP_ENV__Header; _XML SOAP_ENV__Body; }; | | int
则wsdl2h的输出为：

struct tt__ActionEngineEventPayload
{
/// <PRE><BLOCKQUOTE>
///   Request Message
/// </BLOCKQUOTE></PRE>
///
/// Element "RequestInfo" of type SOAP-ENV:Envelope.
    int                                  RequestInfo                    0;	///< Optional element.
};


3、命名空间绑定语法
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	譬如：
	tds     = "http://www.onvif.org/ver10/device/wsdl"
这样，不管http://www.onvif.org/ver10/device/wsdl命名空间在wsdl文件中使用的是什么
简写，在wsdl2h工具生成的头文件中http://www.onvif.org/ver10/device/wsdl的类型都是
使用tds前缀。


4、命名空间头文件导入语法
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	有些命名空间的头文件(在import文件夹下)gsoap已经为我们准备好，不需要使用
wsdl2h工具生成，这时可以使用“命名空间头文件导入语法”，譬如：
	wsdd10  = <http://schemas.xmlsoap.org/ws/2005/04/discovery>
注意，使用的是尖括号而不是引号。这样，如果在其它wsdl文件中使用了http://schemas.xmlsoap.org/ws/2005/04/discovery
中的变量，则wsdl2h生成的头文件中会出现：
	#import "wsdd10.h"
语句。如果没有使用到，则不会出现了onvif.h中。

	有些头文件还有相应的c/c++文件，我们需要把这些c/c++文件引入到我们的工程中去，
譬如duration.c。

4.1、命名空间头文件导入的一个实例
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	在gsoap给出的typemap.dat中已经给出了若干“命名空间头文件导入”行，其中容易让人
迷糊的是wsa和wsdd的导入，它们各有好多行，尤其是wsdd5和wsdd10对应的URL完全相同，那
为什么需要对同一命名空间定义两个头文件呢(wsdd5.h、wsdd10.h)？

	对于这个问题，gsoap官网是这么解释的：
https://www.genivia.com/doc/wsdd/html/wsdd_0.html
	wsdd.h 支持 WS-Discovery1.1 with WS-Addressing 2005/08
	wsdd10.h 支持 WS-Discovery1.0 with WS-Addressing 2004/08
	wsdd5.h  支持 WS-Discovery1.0 with WS-Addressing 2005/08

	这样我们就清晰了：wsdd5.h wsdd10.h只是因为配合的WS-Addressing的版本不同而已。

	WS-Discovery1.0命名空间：
		http://schemas.xmlsoap.org/ws/2005/04/discovery
	WS-Discovery1.1命名空间：
		http://docs.oasis-open.org/ws-dd/ns/discovery/2009/01
	WS-Addressing 2004/08：
		http://schemas.xmlsoap.org/ws/2004/08/addressing
	WS-Addressing 2005/08：
		http://www.w3.org/2005/08/addressing

	那onvif是怎么使用的呢，通过抓包海康相机，我们发现：它WS-Addressing 2004/08和
WS-Addressing 2005/08都使用了，但只使用了WS-Discovery1.0。看上去wsdd10.h和wsdd5.h
都用的上。wsdd.h则不需要。

5、顶层标签与属性的特殊处理
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
https://www.genivia.com/doc/databinding/html/index.html     最下面
	在typemap.dat中有些前缀替换前有小横线，这是怎么回事？譬如：
ser     = <http://schemas.microsoft.com/2003/10/Serialization/>
#       .NET WCF DataContract Serialization Schema root element remappings
_ser__anyURI            == xsd__anyURI
_ser__boolean           == xsd__boolean
_ser__base64Binary      == xsd__base64Binary
_ser__byte              == xsd__byte
_ser__dateTime          == xsd__dateTime
_ser__decimal           == xsd__decimal
_ser__double            == xsd__double
_ser__float             == xsd__float
_ser__int               == xsd__int
_ser__long              == xsd__long
_ser__QName             == xsd__QName
_ser__short             == xsd__short
_ser__string            == xsd__string
_ser__unsignedByte      == xsd__unsignedByte
_ser__unsignedInt       == xsd__unsignedInt
_ser__unsignedLong      == xsd__unsignedLong
_ser__unsignedShort     == xsd__unsignedShort

	其实，注释中已经很明确地说了，对“root element重映射”，但需要wsdl2h -g选项才
会给顶层元素加小横线。