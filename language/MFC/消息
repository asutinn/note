1、事件与消息
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

2、队列消息、非队列消息
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
1)队列消息(Queued Messages)
	消息会先保存在消息队列中，消息循环会从此队列中取消息并分发到各窗口处理。如
鼠标，键盘消息。
2)非队列消息(NonQueued Messages)
	消息会绕过系统消息队列和线程消息队列直接发送到窗口过程被处理。如：WM_ACTIVATE,
WM_SETFOCUS,WM_SETCURSOR,WM_WINDOWPOSCHANGED。
	注意:postMessage发送的消息是队列消息，它会把消息Post到消息队列中；SendMessage
发送的消息是非队列消息，被直接送到窗口过程处理。


3、系统消息队列、线程消息队列
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa


4、UI线程、worker线程
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	Win32说明文件一再强调线程分为UI线程和worker线程两种。GUI线程负责建造窗口以
及处理主消息循环。Worker负责执行纯粹的运算工作，这些运算工作如果放在UI线程内会导
致UI线程的消息队列失去反应。一般而言，UI线程绝不会去做那些不能够马上完成的工作。

	在早期的Windows NT操作系统中，对显示器的图形操作是由一个服务进程提供，就像是
现在Linux上的X Window。但是后来情况发生了变化，微软觉得由服务进程提供图形操作必定
导致大量的进程间通信，从而使系统的效率下降。因此从Windws NT 4.0开始，微软把图形操
作移到了内核。为此微软在原有的系统调用基础上增加了一组图形相关的系统调用供应用层
使用，新增的系统调用我们称之为Win32k扩展系统调用。因此在内核中有两个系统调用表，
一个是原来就有的系统调用表，一个是新增后的Win32k扩展系统调用表。

	在内核中每个线程都有一个数据结构KTHREAD来存储线程的信息，在线程的KTHREAD结
构中有一个ServiceTable指针，这个指针指向本线程所用的系统调用表。每个线程在创建之
初都是使用原本的系统调用表，此后，如果新线程第一次进行了Win32k扩展系统的调用，内
核就会将该线程转换成UI线程，并修改ServiceTable指针，使其指向Win32k扩展系统调用表。
除了修改ServiceTable指针，操作系统还会为这个线程创建一个消息队列，并将这个消息队
列的指针存储到线程的数据结构中。因此我们常说的UI线程，就是比其它普通线程多了一个
消息队列，这是关键。

	如何将一个普通线程变成UI线程呢？只要调用一个GUI相关的API就可以了，例如
GetMessage()、CreateWindow()。

5、窗口与消息循环
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	窗口有一个数据结构，里面会存储很多的信息，其中有3个是我们最关注的，一个是指
向窗口函数的指针WndProc，一个是创建这个窗口的线程指针OwnerThread，还有一个是指向
OwnerThread消息队列的指针MessageQueue。这样当你向一个窗口发送消息时，操作系统就
将这个消息放到MessageQueue所指的队列中。因此，你应该明白，只有创建这个窗口的线程
才能处理这个窗口的消息。那么一个线程如何处理他所创建的窗口消息呢？答案就是在这个
线程中实现消息循环。

	如果一个UI线程没有实现消息循环，那么就无法处理它所创建的窗口消息了。

6、MFC的UI线程、worker线程封装
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
CWinApp是一个用户界面线程对象，派生自CWinThread。

https://zhidao.baidu.com/question/1510355037000365620.html


7、MFC主线程
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
CWinApp是MFC主线程的标准类，派生后的APP类，从InitInstance进入，之后进入了CWinApp类的Run：



1、消息的定义：
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
typedef struct tagMSG
{
	HWND hwnd;
	UINT message; // WM_xxx，例如WM_MOUSEMOVE，WM_SIZE...
	WPARAM wParam;
	LPARAM lParam;
	DWORD time;
	POINT pt;
}MSG;

WIN32中的消息是这样定义的，但我们常涉及到的只是WM_COMMAND消息的命令ID，即wParam字段的
低位两字节。

2、WM_COMMAND消息介绍：
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
MSG消息中有两个参数：wparam、lparam，对WM_COMMAND而言含义如下：
	wParam的高两个字节代表通知码
	wParam的低两字节代表命令ID
	lParam代表发送命令消息的子窗体句柄。

详细解释：
	菜单的通知码为0；加速键的通知码为1。
	命令ID也就是资源脚本中定义的菜单项的命令ID或者加速键的命令ID，也可以是自己定义的ID，ON_COMMAND
就是根据这个ID来分配调用函数的。
	对于菜单和加速键来说，lParam为0，只有控件此项才非0。

3、ON_MESSAGE，ON_COMMAND和ON_NOTIFY的区别
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
在Windows3.1里，控件会将mouse, keybord等等的消息通知它的父窗口，使用的消息就只有
WM_COMMAND，事件种类和控件ID被包含在wParam中，控件的句柄包含在lParam中。

由于wParam和lParam已经满了，当控件要向父窗口发送其它特殊消息同时附带很多信息的时候就没有
地方可以存放它们了。所以Windows3.1中定义了许多其它的消息种类，比如WM_VSCROLL, WM_CTLCOLOR
等等，每种消息wParam,lParam中附带的信息是不同的。

当到了Win32后，控件的种类越来越多，当然不可以为每一个控件都定义一套消息，这样也不利于系统
的扩充。所以在Win32中定义了唯一一个强大的消息 WM_NOTIFY。当然WM_NOTIFY也遵守原来的消息规则，
即只带参数wParam和lParam。唯一不同处在于，此时的lParam中传送的是一个NMHDR指针。不同的控件可
以按照规则对NMHDR进行扩充，因此WM_NOTIFY消息传送的信息量可以相当的大，这个可以看看MSDN中的
相关说明，TreeControl中就有很多这种消息。

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
ON_MESSAGE是处理所有的Windows的消息的，因为所有的消息都以相同的格式传送，也就是ID, 
WPARAM, LPARAM。

ON_COMMAND是专门处理WM_COMMAND消息的，这样我们就不用自己解开WM_COMMAND中wParam和
lParam中传送的控件ID，事件种类…（所有的都在MFC内部解决了：），当然方便了。

ON_NOTIFY更是不用说了，看看他的处理函数，是不是把NMHDR解出来了。

这样一样就一目了然了，ON_COMMAND和ON_NOTIFY都可以用ON_MESSAGE来处理，只不过自己要多做
很多事情。ON_COMMAND和ON_NOTIFY最好就不要互换了！


2、postmessage发送的消息可以使用ON_COMMAND来捕获吗