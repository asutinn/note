#!/usr/bin/env perl
use warnings;
use strict;
use utf8;

#正则表达式：
#用途：
#	模式匹配、捕获、替换
#类型:(非简写情形下界定符可随意选择)
#	m/pattern/[flag] 可简写为 /pattern/[flag]
#	s/pattern/substitution/[flag]
#	qr//
#元字符列表（可转义后表示字符本身）
#	条目
#		.匹配任意一个字符
#		（）用于模式分组、捕获。捕获功能可以在分组前面加两个字符关闭：(?:)
#		[-]用于字符集，匹配单个字符。应该说字符范围更准确，字符集使用use指令
#	量词
#		*前一个条目零次或多次重复，没有模式分组时，前一个条目就是前一个字符
#		+前一个条目一次或多次重复
#		?前一个条目出现一次或零次
#		{,}通用量词
#	其它
#		\用于转义元字符，也用于反向引用捕获
#		|择一匹配，一般用于模式分组内
#		模式匹配操作符选用的定界符
#	特殊
#解释：
#	正则表达式（模式）：表示匹配或不匹配某个字符串的特征模板，注意区分模
#式与通配符
#
#	绑定操作符=~：默认情况下模式匹配的操作对象是$_，绑定操作符告诉perl用
#右边的模式来匹配左边的字符，不是匹配$_。
#
#	模式分组：在perl正则表达式中，圆括号的作用是对字符串分组，圆括号内的
#字符串作为一个整体条目被*+？数量元字符修饰，开启捕获后，每个分组匹配的结
#果可以在模式内反向引用或在匹配结束后获取。
#
#	捕获：每个模式分组默认都开启了捕获。
#
#	不捕获：在圆括号内开头使用"?:"两个字符可以关闭此分组的捕获功能：(?:)
#
#	反向引用：在模式内要表达重复的子串，基本上就可以使用反向引用，表示引用
#处需是前面某个分组捕获到的内容。\1代表引用第一个捕获，依次类推，尤其注意模
#式分组嵌套时的情形。反向引用按最长匹配的规则确认捕获编号，譬如\111代表第111
#个捕获，而不是第1或11个捕获。从perl 5.10开始支持\g{N}格式的捕获编号，把数
#字用花括号引起来，就可以避免之前的歧义。
#
#	捕获编号与分组编号：因为分组的捕获功能是可以关闭的，所以捕获的编号不一
#定等于分组的编号。
#
#	捕获变量：如果匹配成功，捕获组们会把匹配到的子串保存在某处，在正则匹配
#结束以后，我们就可以通过$1、$2...变量形式来引用这些子串。
#
#	捕获变量与反向引用的区别：同一个序号的反向引用内容和捕获变量的内容肯定是
#一样的，但它们却不是同一个事物。反向引用是在匹配过程中跟模式分组联动运作的，
#也就是说反向引用也是匹配的一部分。我们可以把模式匹配想象成一个多步骤循环的过
#程。譬如/(a)\1/这个模式从匹配目标的第一个字符开始循环，第一个循环内，前面模
#式分组成功了，那就会走到反向引用匹配步骤，反向引用匹配不上，从匹配目标的第二
#个字符重新开始循环，依次类推。只有当整体匹配成功后，才会更新捕获变量。
#
#	捕获变量的生存期：捕获变量通常能存活到下一次成功匹配。也就是说，失败的匹配
#不会改动上次成功匹配时捕获的内容。从另一方面说，取捕获变量之前应先判断匹配是否
#成功。
#
#	命名捕获：默认情况下，捕获把匹配到的子串存储在诸如$1、$2...这样的变量中，这
#就像是一个数组，哪天修改了模式可能这个数组的位置就全乱了，后面引用这个数组的地
#方全都要改，代码维护性差。为了应对这种情况，从5.10开始可以在分组内对捕获内容进
#行命名，格式像这样：(?<label>PATTERN)，lable就是此分组的捕获的名字，最终捕获
#内容会存储到特殊哈希变量%+中，这个哈希的key就是分组内的命名。
#
#	择一匹配：类似逻辑或运算符（其实使用的是按位或运算符），多个模式只要
#有一个满足就算匹配上。一般应尽可能配合模式分组使用，譬如/fred(o|r)barney/
#和/fredobarney|fredrbarney/等价，但后者效率会低很多。
#	字符范围：有多种表示方法
#		具体法：譬如[abcwxyz]，等同于（a|b|c|w|x|y|z）
#		编码范围法：譬如[a-cwx-z]，依赖字符集。注意是编码范围，如果某字
#符集a编码后一个编码不是b，那就怂逼了。但一般不会出问题。
#		别名法：譬如\d代表数字，不同字符集覆盖的字符范围也不一样。
#

#模式匹配用绑定操作符=~《perl语言入门6版-p151》
#	默认情况下模式匹配的操作对象是$_，绑定操作符（binding operator, =~）
#告诉perl，拿右边的模式来匹配左边的字符串，而不是匹配$_。


#1、简单模式：把要匹配的字符串放在两个反斜杠之间就组成一个简单模式
my $strTest1 = "Cat: fish, fish, I want to eat fish\n Host: no, I have no fish\n";
my $strTest2 = "abababa\n";
if($strTest2 =~ /(?:(ab){2})\1/)
{
	print "match\n"
}

#2、unicode properties(unicode字符属性)：可以把unicode字符归类匹配。
#类别详见http://perldoc.perl.org/perluniprops.html
#/\p{}/ /\P{}/

#3、元字符
#例子
#	/fred\t*barney/可以匹配 "fredbarney" "fred	barney" "fred		barney"等等
#	/fred.*barney/可以匹配 "fredbarney" "frediiiixxxbarney"等等
#	/((.)(.)\3\2)\1/匹配"h88hh88h"

