材料
	http://blog.csdn.net/Lirx_Tech/article/details/42340619



4. 汇编地址以及标号的本质：
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
	汇编地址的概念在所有汇编编译器里都是统一的，所谓汇编地址，就是编译器给源程序中每条
指令定义的地址，由于编译后的程序可以在内存中浮动（即可以装载在内存中的任意位置），因此
直接用绝对地址（20位的实模式下的物理内存地址）来给源程序中的指令定位的话将不利于程序在
内存中的浮动；

	1)汇编地址定位规则：
	一般规则：
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
		i.在没有使用特殊指令的一般情况下（特别是vstart指令），整个源程序中第一条指令的
汇编地址为0，之后所有指令的汇编地址都是相对于整个源程序第一条指令的偏移地址，即使程序中
分了很多段也是如此，在这种情况下，如果将整个源程序看做一个段的话则汇编地址就是段内偏移地
址；

		ii.在NASM中，所有的标号实质上就是其所在处指令的汇编地址（相对于整个源程序第一
条指令的偏移地址），在编译后会将所有标号都替换成该汇编地址值（即立即数）；

	特殊规则：
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
		i.如果在定义段的时候使用了vstart指令，比如"section my_segment vstart=15"，
则会提醒汇编器，该段起始指令的汇编地址是15，段内的其它指令的汇编地址都是和该段起始指令
地址的偏移量加上15；

！NASM使用关键字section来定义段，后面跟一个段的名称（用户自取），接下来跟一些段的属性定义；

！因此，vstart伪指令就是规定段的其实汇编地址的指令；

！如果vstart=0，则段内的汇编指令就是段内的偏移地址了！！！这种手法经常使用！！

        ii. 使用NASM规则的标准段，是指section .data、section .text、section .bss，这三种标准段都默认包含有vstart=0的含义，因此段内的指令以及标号的汇编地址都是段内偏移地址，并且在加载程序的时候会自动使cs执行.text、ds指向.bss、es指向.data而无需人手工来执行对段寄存器赋值的步骤，而对于i.中的人全权定义段的方式则没有这种自动的步骤，需要亲手对段寄存器进行赋值！

    4) 引用标号：

        i. 和MASM不一样的是NASM大大简化了对标号的引用，不需要再用seg和offset对标号取段地址和偏移地址了；

        ii. 在NASM中，标号就是一个立即数，而这个立即数就是汇编地址而已，仅此而已！！

        iii. 在NASM中不再有MASM中数据标号的概念了，也就不存在什么arr[5]之类的内存寻址形式了！！！！

        iv. 在NASM中所有出现标号的地方都会用标号的汇编地址替换，因此诸如mov ax, tag之类的指令，仅仅就是将一个立即数（tag的汇编地址）传送至ax而已，而不是取tag地址内的数据了！！！如果要取标号处内存中的数据就必须使用[ ]（类似C语言的指针运算符*），比如[tag]就代表取tag地址内存中的数据；


！！！只有段寄存器中存放的才是真实的物理内存段地址（即16的整数倍），标号全部都是源程序的汇编地址！

！这种地址模式有利于程序在内存中浮动，只需要在装载程序（程序装入内存的过程）的时候定义一下段寄存器中的内容即可，其余的偏移地址都能由标号（汇编地址）正确表示）；


    5) 定义标号：

        i. NASM定义标号和MASM定义标号的规则略有不同；

        ii. NASM在定义标号是可以不使用冒号也可以不使用；

        iii. 如果使用了冒号则会是汇编器将其强制视为标号，如果没使用冒号则汇编器会自行推断；

        iv. 汇编器推断是否是标号的规则，首先读入单词，如果单词后跟着一个冒号则将其视为标号，如果没有跟冒号则会先核对其是否是某个指令的名字，如果不是则将其视为标号，因此当标号名和指令名冲突的时候要加冒号，否则可以不加；

        v. NASM规则中，如果标号指示的是一段数据的定义也可以使用冒号定义（当然也可以不使用冒号），这点和MASM不同（MASM指示数据定义的标号在定义时一定不能加冒号），在NASM中可以这样来：

[plain] view plain copy

    data1 db 1, 2, 3  
    string1: db 'abcd'  

！因此NASM在语法上还是相当自由的！

        vi. 标号定义的规范：定义数据时不要使用冒号，在指令行中定义标号时使用冒号，这样以示区分指令地址和数据区域的入口；